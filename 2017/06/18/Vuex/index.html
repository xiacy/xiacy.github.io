<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="#Vuex ####Vuex是什么Vuex是为Vue量身定制的一个状态管理模式和类库，它做为集中的状态容器服务于应用中所有组件，用一系列规则保证状态只能以可预测地方式改变。它也集成了Vue的官网开发工具扩展以提供高级特性，如零配置的时间旅行调试和状态快照导入/导出。 ######什么是“状态管理模式”让我们以一个简单的计数应用开始：123456789101112131415161718new Vu">
<meta property="og:type" content="article">
<meta property="og:title" content="Vuex文档翻译">
<meta property="og:url" content="http://yoursite.com/2017/06/18/Vuex/index.html">
<meta property="og:site_name" content="Xiacy&#39;s Blog">
<meta property="og:description" content="#Vuex ####Vuex是什么Vuex是为Vue量身定制的一个状态管理模式和类库，它做为集中的状态容器服务于应用中所有组件，用一系列规则保证状态只能以可预测地方式改变。它也集成了Vue的官网开发工具扩展以提供高级特性，如零配置的时间旅行调试和状态快照导入/导出。 ######什么是“状态管理模式”让我们以一个简单的计数应用开始：123456789101112131415161718new Vu">
<meta property="og:image" content="http://vuex.vuejs.org/en/images/flow.png">
<meta property="og:image" content="http://vuex.vuejs.org/en/images/vuex.png">
<meta property="og:updated_time" content="2017-06-18T09:25:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vuex文档翻译">
<meta name="twitter:description" content="#Vuex ####Vuex是什么Vuex是为Vue量身定制的一个状态管理模式和类库，它做为集中的状态容器服务于应用中所有组件，用一系列规则保证状态只能以可预测地方式改变。它也集成了Vue的官网开发工具扩展以提供高级特性，如零配置的时间旅行调试和状态快照导入/导出。 ######什么是“状态管理模式”让我们以一个简单的计数应用开始：123456789101112131415161718new Vu">
<meta name="twitter:image" content="http://vuex.vuejs.org/en/images/flow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/18/Vuex/"/>





  <title>Vuex文档翻译 | Xiacy's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiacy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/Vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiacy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiacy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vuex文档翻译</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T00:01:53+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#Vuex</p>
<p>####Vuex是什么<br>Vuex是为Vue量身定制的一个状态管理模式和类库，它做为集中的状态容器服务于应用中所有组件，用一系列规则保证状态只能以可预测地方式改变。它也集成了Vue的官网开发工具扩展以提供高级特性，如零配置的时间旅行调试和状态快照导入/导出。</p>
<p>######什么是“状态管理模式”<br>让我们以一个简单的计数应用开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// state</span></div><div class="line">  data () &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">count</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// view</span></div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</div><div class="line">  `,</div><div class="line">  <span class="comment">// actions</span></div><div class="line">  methods: &#123;</div><div class="line">    increment () &#123;</div><div class="line">      <span class="keyword">this</span>.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这是一个独立的app，它由以下几个部分组成：</p>
<ul>
<li>state，驱动整个应用的数据来源</li>
<li>view，仅是状态的声明式的映射</li>
<li>actions，回应用户输入的可能方式</li>
</ul>
<p>这是一个非常具有代表性的“单向数据流”的形式</p>
<p><img src="http://vuex.vuejs.org/en/images/flow.png" alt="单向数据流"></p>
<p>然而，当多个组件共享相同状态时，这种简明很快失效了：</p>
<ul>
<li>多个视图可能依赖于相同的状态片段</li>
<li>不同视图可能需要改变相同的状态片段</li>
</ul>
<p>针对第一个问题，在深层嵌套的组件内传递属性会变得非常繁琐，而且无法应用在同级组件间。针对第二个问题，我们经常采取的方案是拿到父/子组件的引用或者通过事件来改变或者拷贝多份状态。这两种方式都很容易产生无法维护的代码。</p>
<p>所以我们为什么不从组件中提取出共享的状态并用一个全局的单例来管理它呢?用这种方式，我们的组件树演变为一个大的“视图”，并且任何组件都可以访问状态或者触发行为，而不管它处于组件树的哪一个层级！</p>
<p>另外，通过定义并拆分出涉及状态管理的概念，执行一定的规则，我们代码将变得更加结构化和可维护。</p>
<p>这是Vuex背后最基本的理念，灵感来自于Flux，Redux和The Elm Architecture。不同于这些模式，Vuex是专门为Vue.js量身定制，以便充分利用其细粒度的响应式系统去做高效的更新。</p>
<p><img src="http://vuex.vuejs.org/en/images/vuex.png" alt="Vuex状态管理模式"></p>
<p>######什么时候用它<br>尽管Vuex帮助我们管理共享状态，但它也带来更多的概念和模型，我们需要在短期和长期的成效间做出取舍。</p>
<p>如果你从未构建过一个大规模的单面应用就直接拥抱Vuex，它可能会使你感到复杂且晦涩。这很正常，如果你的应用很简单，你大概不需要Vuex，一个简单的<a href="http://vuejs.org/guide/components.html#Non-Parent-Child-Communication" target="_blank" rel="external">全局事件总线</a>可以满足你所有需求。但是如果你正在构建一个中大型规模的单页应用，有可能你遇到一些情况，使你思考如何在组件之外更好地处理状态，Vuex会自然而然地成为你的下一步选择。这里引用Redux作者Dan Abramov的一句话：</p>
<blockquote>
<p>Flux libraries are like glasses: you’ll know when you need them.</p>
</blockquote>
<p>####开始<br>任何Vuex应用的核心都是<strong>store</strong>。store从根本上说是一个持有应用<strong>状态</strong>的容器，有两个地方让Vuex store与简单的全局对象不同：</p>
<ol>
<li>Vuex stores是响应式的。当Vue组件从中检索状态时，如果store中的状态改变，组件自身会响应且高效地更新。</li>
<li>你不能直接修改store中的状态。唯一的方式是显示地<strong>提交更改</strong>。这一点保证了每次状态改变能留下可追踪的记录，并且使我们可以利用工具帮助我们更好地理解应用。</li>
</ol>
<p>######最简单的Store</p>
<blockquote>
<p>注意：我们会在后面的文档示例中使用ES2015语法。如果你还不了解它，可以先查阅下<a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">文档</a>。</p>
</blockquote>
<p>安装完Vuex以后，让我们创建一个store。只需要提供一个初始的状态对象和一些mutations，这非常简单:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果你使用模块系统，记得先调用 Vue.use(Vuex)</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">    	state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>现在，你可以通过<code>store.state</code>访问状态对象，使用<code>store.commit</code>方法来触发状态改变：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'increment'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></div></pre></td></tr></table></figure></p>
<p>重申一次，我们使用提交改变的方式而不是直接修改<code>store.state.count</code>的原因在于我们想严格地追踪它。这种简单的约定让你的意图更加明确，以便你能在阅读代码时更好地推断出状态的改变。另外，这也为我们提供了机会去实现那些可以记录每一次变化，创建状态快照，甚至执行时间旅行调试的工具。</p>
<p>在组件中使用store状态只需要将状态做为计算属性返回，因为store状态是响应式的。触发状态改变只需要在组件方法中提交改变。<br>这里有一个示例<a href="https://jsfiddle.net/yyx990803/n9jmu5v7/" target="_blank" rel="external">most basic Vuex counter app</a>。<br>接下来，我们会通过一些很多出色的细节来讨论每一个核心概念，从<a href="http://vuex.vuejs.org/en/state.html" target="_blank" rel="external">状态</a>开始。</p>
<p>####状态</p>
<p>######单一地状态树<br>Vuex使用<strong>单一的状态树</strong>，这就是说，这个对象包含了你应用所有层级的状态，充当“单一的数据源”，这也通常意味着你在每个应用中只能拥有一个store。单一的状态树使查找某一具体的状态片段直截了当，并且允许我们轻松地创建当前应用的快照用作调试目的。</p>
<p>单一状态树并不与模块化冲突，在后面的章节我们会讨论如何把状态和mutations分离到不同的子模块中。</p>
<p>######在Vue组件中获取Vuex状态<br>那么如何在Vue组件中展示Store中的状态呢？因为Vuex stores是响应式的，最简单的“检索”方式就是通过<a href="http://vuex.vuejs.org/en/state.html" target="_blank" rel="external">计算属性</a>简单返回store中的状态:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让我们创建一个计数组件</span></div><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    count () &#123;</div><div class="line">      <span class="keyword">return</span> store.state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每当<code>store.state.count</code>改变，就会导致计算属性被重新求值，从而触发关联的DOM更新。<br>然而，这种模式使得组件依赖于全局的store实例，当使用模块系统时，需要在每个使用store状态的组件中导入store，并且在测试组件时同样需要模拟。<br>Vuex提供了一种机制向所子组件“注入”store，通过在根组件上使用<code>store</code>选项(通过<code>Vue.use(Vuex)</code>开启)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  // 使用&quot;store&quot;选项</div><div class="line">  // 这样会向所有子组件注入store</div><div class="line">  store,</div><div class="line">  components: &#123; Count &#125;,</div><div class="line">  template `</div><div class="line">    &lt;div class=&quot;app&quot;&gt;</div><div class="line">      &lt;counter&gt;&lt;/counter&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过为根实例提供<code>store</code>选项，store会被注入到根实例的所有子组件中，在子组件中可以使用<code>this.$store</code>访问。让我们修改一下<code>Counter</code>的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const Counter = &#123;</div><div class="line">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</div><div class="line">  computed: &#123;</div><div class="line">    count () &#123;</div><div class="line">      return this.$store.state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######<code>mapState</code><br>当一个组件需要使用多个store状态属性或getter方法时，声明所有这些计算属性会很繁琐，为了处理这种情况，我们可以利用<code>mapState</code>，它可以帮助我们生成计算方法，减少输入：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在独立版本中，帮助类以Vuex.mapState形式暴露出来</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: mapState(&#123;</div><div class="line">    <span class="comment">// 箭头函数会让代码更加简洁</span></div><div class="line">    count: state = state.count,</div><div class="line"></div><div class="line">    <span class="comment">// 传递字符串值'count'等同于`state =&gt; state.coount`</span></div><div class="line">    countAlias: <span class="string">'count'</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 为了使用`this`来访问本地状态，必须使用一个常规的方法</span></div><div class="line">    countPlusLocalState (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当映射的计算属性的名字跟子状态树的名字一致时，我们也可以向<code>mapState</code>传入一个字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  // 把store.state.count映射到this.count</div><div class="line">  &apos;count&apos;</div><div class="line">])</div></pre></td></tr></table></figure></p>
<p>######对象展开符<br>注意<code>mapState</code>返回的是一个对象。那么我们怎么把它与其它局部的计算属性结合到一起呢？通常，我们需要使用一个工具方法去把多个对象合并为一个，这样我们就可以把这个最终的对象传给<code>computed</code>。但是，使用<a href="this.count">对象展开符</a>(ECMAScript第三阶段提案)，我们就可以极大地简化语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">  <span class="comment">// 使用对象展开符合并属性到外层的对象</span></div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######组件依然可以有局部状态<br>使用Vuex并不意味着你应该把<strong>所有</strong>状态放到Vuex中，尽管把更多状态放置到Vuex中使得状态变化更明确，更利于调试，但有时候这会使得代码更加复杂晦涩。如果一个状态片段完全只属于一个组件，把它作为局部状态会非常合适。你需要权衡利弊，根据开发需求做出适合的决定。</p>
<p>####Getters<br>有时候我们可能需要基于store状态计算出新的状态，例如过滤一个列表得到它的数量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果多个组件需要使用这种方式，我们可以重复这样的代码，或者把它提取到一个公共的文件中，在多个地方导入，但这两种方式都不够直观。<br>Vuex允许我们在store中定义“getters”(把它们想像成store的计算属性)。Getters会把state做为它们接收到的第一个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">todos</span>: [</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>getters会暴露在<code>store.getters</code>对象中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></div></pre></td></tr></table></figure></p>
<p>getters会接收其它getters做为其第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.getters.doneTodosCount <span class="comment">// =&gt; 1</span></div></pre></td></tr></table></figure></p>
<p>现在我们可以在组件中方便地使用它了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######<code>mapGetter</code><br><code>mapGetter</code>只是简单地把store中的getters映射成为局部的计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: &#123;</div><div class="line">    <span class="comment">// 使用对象展开符把getters合并到计算属性中</span></div><div class="line">    ...mapGetters([</div><div class="line">      <span class="string">'doneTodosCount'</span>,</div><div class="line">      <span class="string">'anotherGetter'</span>,</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想把getters映射到不同名称的计算属性中，那就使用对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  <span class="comment">// 映射 this.doneCount 到 store.getters.doneTodosCount</span></div><div class="line">  doneCount: <span class="string">'doneTodosCount'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>####Mutations<br>唯一改变Vuex store状态的方式是通过提交mutation，Vuex的mutation与事件非常类似：每个mutation都有一个字符串的<strong>类型</strong>和<strong>处理函数</strong>。处理函数是我们真正执行状态修改的地方，它也会接收state做为第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// 改变状态</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>你不能直接调用mutation处理函数，这里的选项更像是事件注册：“当一个<code>increment</code>类型的mutation被触发时，就调用这个处理函数。”为了调用一个mutation处理函数，你需要使用<strong>store.commit</strong>并传入它的类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure></p>
<p>######为commit传入payload参数<br>你可以为<code>store.commit</code>传入一个被称为<strong>payload</strong>的额外的参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, n) &#123;</div><div class="line">    state.count += n</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>在多数情况下，payload应该是一个包括许多字段的对象，这样mutation会更具描述性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>######对象形式的commit<br>另一种提交改变的方式是传入一个具有<code>type</code>属性的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.commit(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'increment'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当使用对象形式的commit时，整个对象会做为payload传递给mutation处理函数，所以处理函数保持同样的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######静默提交</p>
<blockquote>
<p>注意：当我们在devtools中实现mutation过滤这个特性很可能会被废弃掉。</p>
</blockquote>
<p>默认的，每一次提交都会被发送给插件(如devtools)，然而在有些情况下，你可能不想插件记录下每一次状态变化。短时间内的多次提交或者轮询不总是需要被记录下来，这些情况下，你可以向<code>store.commit</code>传入第三个参数让特定的mutation对插件保持“沉默”：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">1</span></div><div class="line">&#125;, &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 对象形式的提交</span></div><div class="line">store.commit(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'increment'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">1</span></div><div class="line">&#125;, &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>######mutations实现了Vue的响应式规则<br>由于Vue使Vuex store的状态具有响应式，当我们修改状态，监听这个状态的Vue组件会自动地更新。这也就是说Vuex跟使用单纯的Vue遵循同样的响应式规则：</p>
<ol>
<li>优先初始化你预期的所有状态的初值。</li>
<li>当向对象增加新属性时，你应该：</li>
</ol>
<ul>
<li>使用<code>Vue.set(obj, &#39;newProp&#39;, 123)</code>，或者-</li>
<li>把对象替换成新的。例如，使用对象展开符语法我们可以写成这样：<br><code>state.obj = { ...state.obj, newProp: 123 }</code></li>
</ul>
<p>######使用常量定义mutation类型<br>在各类Flux实现中，把mutation类型定义成常量是很常见的模式，这样可以利用像linter这样的工具，把所有常量放置到一个单独地文件中可以让你的合作者大致了解到在你整个应用中可以有哪些mutation：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></div><div class="line"></div><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> sotre = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="comment">// 我们可以使用ES2015计算属性名的特性</span></div><div class="line">  <span class="comment">// 去使用一个常量作为方法名</span></div><div class="line">  mutations: &#123;</div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      <span class="comment">// 修改状态</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>是否使用常量很大程度上是个人喜好-在多人开发的大型项目中很有用处，但是如果你不使用它，这完全是可选的。</p>
<p>######mutations必须是同步的<br>需要记住一个重要的规定，<strong>mutation处理函数必须是同步的</strong>。为什么呢？我们思考下下面这个示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mutations: &#123;</div><div class="line">  someMutation (state) &#123;</div><div class="line">    api.callAsyncMethod(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在想象我们正在调试这个应用并且正在查看devtool的修改日志。每一次修改都被记录下来，devtool需要捕获状态“before”和“after”的快照，然而，示例mutation中异步的回调让这不可能做到：在mutation提交之后回调函数并没有执行，没有办法让devtool知道什么时候回调函数会被真正调用，在回调函数中进行的状态修改实质上是无法被追踪到的！</p>
<p>######在组件中提交修改<br>你可以在组件中使用<code>this.$store.commit(&#39;xxx&#39;)</code>来提交修改，或者使用<code>mapMutations</code>来影射组件方法到<code>store.commit</code>的调用(依赖于在根组件注入<code>store</code>)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// 映射 this.increment() 到 this.$store.commit('increment')</span></div><div class="line">    ]),</div><div class="line">    ...mapMutations(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// 映射 this.add() 到 this.$store.commit('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######迈向actions<br>异步调用与状态mutation结合到一起会让你的程序非常难追踪。例如，你调用两个有异步回调修改状态的方法，你怎么知道什么时候它们被调用了，哪个被先调用了？这就是为什么我们要分离出这两个概念。在Vuex中，<strong>mutation是同步的事务</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'increment'</span>)</div><div class="line"><span class="comment">// "increment"导致的状态改变必须在这一刻完成</span></div></pre></td></tr></table></figure></p>
<p>为了处理异步操作，让我们介绍<a href="http://vuex.vuejs.org/en/actions.html" target="_blank" rel="external">Actions</a></p>
<p>####Actions<br>actions与mutations很相似，不同点是：</p>
<ul>
<li>actions提交mutations，而不是直接修改状态</li>
<li>actions可以包含任意异步操作</li>
</ul>
<p>让我们注册一个简单的action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">state</span>: &#123;</div><div class="line">    <span class="attr">count</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">  	increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      context.commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>action处理函数接收一个context对象，context对象与store实例暴露一组相同的方法或属性，所以你可以调用context.commit来提交mutation，    或者通过context.state和context.getters来访问state和getters。一会介绍完<a href="http://vuex.vuejs.org/en/modules.html" target="_blank" rel="external">Modules</a>后我们就会明白为什么这个context对象不是store实例本身。</p>
<p>实践中，我们通常使用ES2015<a href="https://github.com/lukehoban/es6features#destructuring" target="_blank" rel="external">参数解构</a>来简化代码（特别是当我们需要多次调用commit时）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  increment (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'increment'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######分发action<br>action使用<code>store.dispatch</code>触发：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure></p>
<p>这种写法第一眼看上去很愚蠢：如果我们想要增加计数，为什么不直接调用<code>store.commit(&#39;increment&#39;)</code>呢？是这样的，记住<strong>mutations必须是同步的</strong>，但action不是。我们可以在action做异步操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  incrementAsync (&#123; commit &#125;) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>action支持同样的payload格式和对象形式调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dispatch with a payload</span></div><div class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// dispatch with an object</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">  <span class="attr">amount</span>: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>一个更实际的真实代码中的action例子将是一个结算购物车的action，它涉及<strong>调用异步API</strong>和<strong>提交多个mutation</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">actions: ｛</div><div class="line">  checkout (&#123; commit &#125;) &#123;</div><div class="line">    <span class="comment">// save the items currently in the cart</span></div><div class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added];</div><div class="line">    <span class="comment">// send out checkout request, and optimistically</span></div><div class="line">    <span class="comment">// clear the cart</span></div><div class="line">    commit(types.CHECKOUT_REQUEST)</div><div class="line">    <span class="comment">// the shop API accepts a success callback and a failure callback</span></div><div class="line">    shop.buyProducts(</div><div class="line">      products,</div><div class="line">      <span class="comment">// handle success</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS)</div><div class="line">      <span class="comment">// handle failure</span></div><div class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">｝</div></pre></td></tr></table></figure></p>
<p>注意，我们正在实现一个异步操作流程，通过提交它们记录action的副作用（状态改变）。</p>
<p>######在组件中分发action<br>你可以在组件中通过<code>this.$store.dispatch(&#39;xxx&#39;)</code>来分发action，或者使用<code>mapActions</code>来映射组件方式到<code>store.dispatch</code>的调用（需要在根组件注入<code>store</code>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'increment'</span> <span class="comment">// map this.increment() to this.$store.dispatch('increment')</span></div><div class="line">    ]),</div><div class="line">    ...mapActions(&#123;</div><div class="line">      <span class="attr">add</span>: <span class="string">'increment'</span> <span class="comment">// map this.add() to this.$store.dispatch('increment')</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######组合actions<br>action通常是异步的，那么我们怎么知道一个action什么时候完成呢？更重要的是，我们怎么把多个action组合到一起来处理更复杂的异步流程？</p>
<p>首先要知道<code>store.dispatch</code>可以使用触发action处理函数返回的Promise，并且也返回它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'someMutation'</span>)</div><div class="line">        resolve()</div><div class="line">      &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>同样在另一个action中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'someOtherMutation'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，如果我们利用<a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="external">async/await</a>，一个    马上确定的javascript特性，我们可以像下面这样组合action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// assuming getData() and getOtherData() return Promises</span></div><div class="line"></div><div class="line">actions: &#123;</div><div class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</div><div class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</div><div class="line">  &#125;,</div><div class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</div><div class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// wait for actionA to finish</span></div><div class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>store.disptach</code>可以触发不同模块中的多个action处理函数。在这种情况下返回值会是一个Promise，这个Promise在所有被触发的处理函数都被解决后才会被解决。</p>
</blockquote>
<p>####Modules<br>因为使用单一状态树，我们应用中的所有状态都包含在一个大对象中。然而，当我们的应用规模增涨，store会变得非常臃肿。</p>
<p>为了解决这个问题，Vuex允许我们把store拆分成<strong>模块</strong>。每个模块可以包含它自己的状态，mutations，actions，getters，甚至是内嵌的模块-可以一直分下去：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">store.state.a <span class="comment">// -&gt; moduleA's state</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB's state</span></div></pre></td></tr></table></figure></p>
<p>######模块局部状态<br>在一个模块的mutations和getters中，第一个接收到的参数将是<strong>模块局部状态</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// state is the local module state</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类似的，在模块中的action，<code>context.state</code>会暴露局部状态，根状态会以<code>context.rootState</code>形式暴露：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOdd (&#123; state, commit &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> (state.count % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，在模块中的getters，根状态会以第三个参数的形式暴露出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######使用命名空间<br>注意，模块中的action，mutation和getter仍然是注册在<strong>全局命名空间</strong>-这样允许多个模块响应相同的mutation/action类型。你可以通过为模块资源加前缀或后缀的方式来避免命名冲突，而且你应该这样做，当你正在写一个可以复用的Vuex模块，它将被应用到未知的环境。例如，我们想要创建一个todo模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// types.js</span></div><div class="line"></div><div class="line"><span class="comment">// define names of getters, actions and mutations as constants</span></div><div class="line"><span class="comment">// and they are prefixed by the module name `todos`</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> DONE_COUNT = <span class="string">'todos/DONE_COUNT'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> FETCH_ALL = <span class="string">'todos/FETCH_ALL'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_DONE = <span class="string">'todos/TOGGLE_DONE'</span></div><div class="line"></div><div class="line"><span class="comment">// modules/todos.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'./types'</span></div><div class="line"></div><div class="line"><span class="comment">// define getters, actions and mutations using prefixed names</span></div><div class="line"><span class="keyword">const</span> todosModule = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">todos</span>: [] &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    [types.DONE_COUNT] (state) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">actions</span>: &#123;</div><div class="line">    [types.FETCH_ALL] (context, payload) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  mutations: &#123;</div><div class="line">    [types.TOGGLE_DONE] (state, payload) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>######动态模块注册<br>你可以使用<code>store.registerModule</code>在<code>store</code>创建之后注册一个模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这个模块的状态会以<code>store.state.myModule</code>的形式暴露出去。</p>
<p>动态模块注册让其它Vue插件也可以使用Vuex做状态管理，通过附加一个模块到应用的store。例如，<a href="https://github.com/vuejs/vuex-router-sync" target="_blank" rel="external">vuex-router-sync</a>库集成了vue-router与vuex，通过动态附加的模块管理应用的路由状态。</p>
<p>你也可以通过<code>store.unregisterModule(moduleName)</code>移除一个动态注册的模块。注意，你不可以使用这个方法移除静态模块（在store创建时声明）。</p>
<p>####应用结构<br>Vuex没有真正限制你如何组织代码结构。当然，它强制实行了一组更高级别的原则：</p>
<ol>
<li>应用级别的状态集中在store中</li>
<li>唯一修改状态的方式是提交<strong>mutations</strong>，它是同步的。</li>
<li>异步逻辑应该被封装，并使用<strong>actions</strong>来组合它们</li>
</ol>
<p>只要遵循这些规则，如何组织项目由你自己决定。如果你的store文件变得非常庞大，只需要简单地拆分actions，mutations，getters到独立的文件。</p>
<p>对于重大应用，我们很可能需要使用模块。这里有一个项目结构的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">├── index.html</div><div class="line">├── main.js</div><div class="line">├── api</div><div class="line">│   └── ... # abstractions for making API requests</div><div class="line">├── components</div><div class="line">│   ├── App.vue</div><div class="line">│   └── ...</div><div class="line">└── store</div><div class="line">    ├── index.js          # where we assemble modules and export the store</div><div class="line">    ├── actions.js        # root actions</div><div class="line">    ├── mutations.js      # root mutations</div><div class="line">    └── modules</div><div class="line">        ├── cart.js       # cart module</div><div class="line">        └── products.js   # products module</div></pre></td></tr></table></figure>
<p>作为参考，检出<a href="https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart" target="_blank" rel="external">Shopping Cart Example</a>项目。</p>
<p>####插件<br>Vuex store接受plugins选项为每个mutation暴露勾子。Vuex插件只是一个简单的接收store做为唯一参数的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> myPlugin = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// store初始化时调用</span></div><div class="line">  store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 每个mutation之后调用</span></div><div class="line">    <span class="comment">// mutation以&#123; type, payload &#125;形式进入</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以像这样使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  plugins: [myPlugin]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>######在插件内提交mutation<br>跟组件类似，插件也不允许直接修改状态，它只能通过提交mutation来触发改变。<br>通过提交mutation，组件可以被用来同步数据源到store。例如，同步websocket数据到store(这只是一个人为的示例，在现实中，createPlugin函数可以提供更多的选项以处理更复杂的任务)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createWebSocketPlugin</span>(<span class="params">socket</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">store</span> =&gt;</span> &#123;</div><div class="line">    socket.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">      store.commit(<span class="string">'receiveData'</span>, data)</div><div class="line">    &#125;)</div><div class="line">    sotre.subscribe(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (mutation.type === <span class="string">'UPDATE_DATA'</span>) &#123;</div><div class="line">        socket.emit(<span class="string">'update'</span>, mutation.payload)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> plugin = createWebSocketPlugin(socket)</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Sotre(&#123;</div><div class="line">  state,</div><div class="line">  mutations,</div><div class="line">  <span class="attr">plugins</span>: [plugin]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>######生成状态快照<br>有时候插件需要接收状态的“快照”，并且比较修改前和修改后的状态。为了实现这个功能，你需要对状态对象做深拷贝：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> myPluginWithSnapshot = <span class="function"><span class="params">sotre</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> prevState = _.cloneDeep(store.state)</div><div class="line">  store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> nextState = _.cloneDeep(state)</div><div class="line"></div><div class="line">    <span class="comment">// 比较prevState与nextState</span></div><div class="line"></div><div class="line">    <span class="comment">// 为下一个mutation保存状态</span></div><div class="line">    prevState = nextState</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>生成状态快照的插件只应该被用在开发过程中。</strong>当我们使用Webpack或Browserify时，我们可以让构建工具帮助我们处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  plugins: process.evn.NODE_ENV !== <span class="string">'production'</span></div><div class="line">    ? [myPluginWithSnapshot]</div><div class="line">    : []</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面的插件默认会启用。在生产环境中，你需要Webpack下的<a href="https://webpack.github.io/docs/list-of-plugins.html#defineplugin" target="_blank" rel="external">DefinePlugin</a>或Browserify下的<a href="https://github.com/hughsk/envify" target="_blank" rel="external">envify</a>在最终构建的时候把<code>process.evn.NODE_ENV !== &#39;production&#39;</code>值转换成<code>false</code>。</p>
<p>######内置的日志插件</p>
<blockquote>
<p>当你使用<a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a>时，你不需要它。<br>Vuex提供一个日志插件以供普通地调试使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'vuex/dist/logger'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">plugins</span>: [createLogger()]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>createLoggor方法可以配置一些选项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> logger = createLogger(&#123;</div><div class="line">  <span class="attr">collapsed</span>: <span class="literal">false</span>, <span class="comment">// 自动展开记录的mutation</span></div><div class="line">  transformer (state) &#123;</div><div class="line">    <span class="comment">// 在记录state前转换</span></div><div class="line">    <span class="comment">// 例如只返回一个特定的子状态树</span></div><div class="line">    <span class="keyword">return</span> state.subTree</div><div class="line">  &#125;,</div><div class="line">  mutationTransformer (mutation) &#123;</div><div class="line">    <span class="comment">// mutation以&#123; type, payload &#125;形式记录</span></div><div class="line">    <span class="comment">// 我们可以以任意方式格式化</span></div><div class="line">    <span class="keyword">return</span> mutation.type</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>日志文件也可以通过一个<code>&lt;script&gt;</code>标签直接引入，这会暴露一个全局的createVuexLogger方法。<br>注意，日志插件创建了状态的快照，所以只能在开发中使用。</p>
<p>####严格模式<br>当创建Vuex store的时候，可以简单传入<code>strict: true</code>来开启严格模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  strict: <span class="literal">true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在严格模式中，一但vuex的state在mutation处理函数之外被修改，就会抛出异常。这保证了所有的状态改变都可以被调试工具跟踪。</p>
<h6 id="开发环境-vs-生产环境"><a href="#开发环境-vs-生产环境" class="headerlink" title="开发环境 vs. 生产环境"></a>开发环境 vs. 生产环境</h6><p><strong>不要在生产环境开启严格模式！</strong>严格模式会深度监测状态树以检测不合法的状态修改–确保在生产环境中关掉严格模式以避免性能损耗。</p>
<p>与插件类似，我们可以让构建工具处理它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  strict: process.env.NODE_ENV !== <span class="string">'production'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>####表单处理<br>当开启严格模式时，在Vuex状态片段上使用<code>v-model</code>会需要些小技巧：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"obj.message"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>假设<code>obj</code>是一返回store中对象的计算属性，当用户输入时，<code>v-model</code>会尝试直接修改<code>obj.message</code>。在严格模式下，这会导致一个错误，因为状态修改操作不是在Vuex mutation处理函数中执行的。</p>
<p>处理这种情况的”Vuex方式”是绑定<code>&lt;input&gt;</code>的值，并且绑定一个操作到<code>input</code>或<code>change</code>事件上：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">computed: &#123;</div><div class="line">  ...mapState(&#123;</div><div class="line">    <span class="attr">message</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line"><span class="attr">methods</span>: &#123;</div><div class="line">  updateMessage (e) &#123;</div><div class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是mutation处理函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  updateMessage (state, message) &#123;</div><div class="line">    state.obj.message = message;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="双向的计算函数"><a href="#双向的计算函数" class="headerlink" title="双向的计算函数"></a>双向的计算函数</h6><p>诚然，上面的代码比<code>v-model</code>加local state的方式要复杂的多，并且我们丢失了<code>v-model</code>的一些很有用的特性。一种变通的方式是使用带setter的双向计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">computed: &#123;</div><div class="line">  <span class="attr">message</span>: &#123;</div><div class="line">    get () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</div><div class="line">    &#125;,</div><div class="line">    set (value) &#123;</div><div class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####测试<br>在Vuex中我们主要想做单元测试的部分是<code>mutations</code>和<code>actions</code>。</p>
<p>######测试mutations</p>
<p>######测试actions</p>
<p>######测试getters</p>
<p>######运行测试</p>
<p>####热重载</p>
<p>####API文档</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xiacy" />
          <p class="site-author-name" itemprop="name">Xiacy</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#开发环境-vs-生产环境"><span class="nav-number">1.</span> <span class="nav-text">开发环境 vs. 生产环境</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#双向的计算函数"><span class="nav-number">2.</span> <span class="nav-text">双向的计算函数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiacy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
